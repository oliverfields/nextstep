#!/bin/bash

# Function to print a warning message (Yellow)
warning() {
  echo -e "\033[33mWarning: $1\033[0m"
}


# Function to print an error message and exit with status 1 (Red)
error() {
  echo -e "\033[31mError: $1\033[0m"
  exit 1
}


# Help message
show_help() {
  echo "Usage: $0 [-h|--help] [-t|--track <path>] [-u|--untrack <path>] [<path>]"
  echo ""
  echo "Options:"
  echo "  -h, --help               Show this help message"
  echo "  -l, --list               List tracked nextstep files"
  echo "  -t, --track <path>       Add a file path to the tracker config, create file if not exists"
  echo "  -u, --untrack <path>     Remove a file path from the tracker config"
  echo ""
  echo "Example: $ nextstep -> list next step for each tracked file"
  echo "Example: $ nextstep my_project.nextstep -> list all steps for file"
  echo ""
  exit 0
}


safe_commit() {
    # Safely commits and pushes a task file in a git repo
    # - Commits only the task file
    # - Works safely on any checked-out branch
    # - Checks the remote version of the same branch
    # - Halts on staged changes, merge conflicts, or remote changes

    local TASK_FILE="$1"

    if [ -z "$TASK_FILE" ]; then
        error "safe_commit <task_file>"
    fi

    # Ensure inside a git repo
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        error "Not inside a git repository"
    fi

    # Ensure no staged changes on other files
    local STAGED_OTHERS
    STAGED_OTHERS=$(git diff --cached --name-only | grep -v "^$TASK_FILE$" || true)
    if [ -n "$STAGED_OTHERS" ]; then
        error "Other files are staged. Commit or stash them first:"
        echo "$STAGED_OTHERS"
    fi

    # Ensure no staged changes on the task file itself
    if git diff --cached --name-only | grep -q "^$TASK_FILE$"; then
        error "Task file $TASK_FILE has staged changes. Please unstage or commit them manually."
    fi

    # Fetch latest from remote
    git fetch origin

    # Get the current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Check if the remote task file has changed
    if ! git diff --quiet "$TASK_FILE" "origin/$current_branch"; then
        error "Remote task file $TASK_FILE has changes. Please pull and resolve before committing."
    fi

    # Check for unstaged changes in task file
    if git diff --quiet "$TASK_FILE"; then
        return 0
    fi

    # Check for merge conflicts in task file
    if git ls-files -u | grep -q "^$TASK_FILE"; then
        error "$TASK_FILE has merge conflicts. Resolve before committing."
    fi

    # Stage only the task file
    git add "$TASK_FILE" || error "Unable to git add $TASK_FILE"

    # Commit the task file
    git commit -m "Update nextstep file $TASK_FILE" || error "Unable to git commit $TASK_FILE"

    # Push to origin
    git push || error "Unable to git push $TASK_FILE"

    echo "Task file $TASK_FILE committed and pushed successfully."
}


config_file="$HOME/.config/nextstep"
file_list=$(sort "$config_file")
list_type="next_step"

# ---- Parse command-line arguments ----
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      show_help
      ;;
    -l|--list)
      list_type="files"
      ;;
    # ---------------- TRACK ----------------
    -t|--track)
      shift
      track_path="$1"
      if [ -z "$track_path" ]; then
        error "Missing argument for -t|--track"
      fi

      # Convert relative → absolute
      if [[ "$track_path" != /* ]]; then
        track_path="$PWD/$track_path"
      fi

      # Ensure file exists
      if [ ! -f "$track_path" ]; then
        touch "$track_path" || error "Unable to create: $track_path"
      fi

      # Ensure config directory + file exist
      mkdir -p "$(dirname "$config_file")"
      touch "$config_file"

      # Check for duplicates
      if grep -Fxq "$track_path" "$config_file"; then
        warning "Path already tracked: $track_path"
        exit 0
      fi

      echo "$track_path" >> "$config_file"
      #echo "Added: $track_path"
      vim "$track_path"
      exit 0
      ;;

    # ---------------- UNTRACK ----------------
    -u|--untrack)
      shift
      untrack_path="$1"
      if [ -z "$untrack_path" ]; then
        error "Missing argument for -u|--untrack"
      fi

      # Convert relative → absolute
      if [[ "$untrack_path" != /* ]]; then
        untrack_path="$PWD/$untrack_path"
      fi

      # Check if the config file exists
      if [ ! -f "$config_file" ]; then
        warning "Configuration file not found at $config_file"
        exit 0
      fi

      # Check if the path is in the config file
      if ! grep -Fxq "$untrack_path" "$config_file"; then
        warning "Path not tracked: $untrack_path"
        exit 0
      fi

      # Remove the entry
      grep -Fxv "$untrack_path" "$config_file" > "$config_file.tmp" &&
      mv "$config_file.tmp" "$config_file"

      #echo "Removed: $untrack_path"
      exit 0
      ;;

    *)
      file_list="$1"
      list_type="file"
      ;;
  esac
  shift
done

# ---- Existing nextstep TODO-scanning logic ----

if [ ! -f "$config_file" ]; then
  error "Configuration file not found at $config_file"
fi

# Get next step id string
next_step_prefix="$(grep '^next_step=' "$config_file")"
next_step_prefix="${next_step_prefix#next_step=}"
[ "$next_step_prefix" = "" ] && next_step_prefix=TODO

# Get next step id string
git_commit="$(grep '^git_commit=' "$config_file")"
git_commit="${git_commit#git_commit=}"

[ "$next_step_prefix" = "" ] && next_step_prefix=TODO
selection="$(

while IFS= read -r file_path; do
  # skip config settings
  if [[ "$file_path" == next_step=* ]]; then continue; fi
  if [[ "$file_path" == git_commit=* ]]; then continue; fi

  if [ -f "$file_path" ]; then

    if [ "$list_type" = "next_step" ] || [ "$list_type" = "file" ]; then
      line_number=0
      while IFS= read -r line; do
        let line_number=line_number+1
        if [[ "$line" == TODO\ * ]]; then
          task="${line#TODO }"
          [[ "$file_path" =~ ^"$HOME"(/|$) ]] && file_path_display="~${file_path#$HOME}" || file_path_display="$file_path"

          # Print the file path (blue), task (bold white), and line number (cyan)
          echo -e "\033[36m$file_path_display:$line_number:\033[37m$task"

          [ "$list_type" = "next_step" ] && break
        fi
      done < "$file_path"
    else
      echo -e "\033[36m$file_path\033[37m"
    fi
  else
    warning "File not found: $file_path"
  fi
done <<< "$file_list" | fzy --lines=$(($(tput lines)-2)) )"


[ "$selection" = "" ] && exit 0

#strips out any escape codes/colors
selection="$(echo $selection | sed 's/\x1b\[[0-9;]*m//g')"

IFS=':' read -r file_path line_number task <<< "$selection"

[[ "$file_path" =~ ^~ ]] && file_path="$HOME${file_path#?}"

if [ "$line_number" != "" ]; then
  vim +$line_number "$file_path"
else
  vim "$file_path"
fi

[ "$git_commit" = "yes" ] && safe_commit "$file_path"
