#!/bin/bash

# Function to print a warning message (Yellow)
warning() {
  echo -e "\033[33mWarning: $1\033[0m" >&2
}

# Function to print an error message and exit with status 1 (Red)
error() {
  echo -e "\033[31mError: $1\033[0m" >&2
  exit 1
}

# Help message
show_help() {
  echo "Usage: $0 [-e|--edit] [-h|--help] [-t|--track <path>] [-u|--untrack <path>] [-l|--list-steps] [<path>]"
  echo ""
  echo "NEXTSTEP rules:"
  echo "  Only files whose name is exactly 'NEXTSTEP' are valid."
  echo "  Ordering is important, both of steps in NEXTSTEP files and paths in tracker file."
  echo "  A step is a single line of that starts with 'NEXT '"
  echo ""
  echo "Options:"
  echo "  -e, --edit               Edit the tracker file"
  echo "  -h, --help               Show this help message"
  echo "  -l, --list-steps <path>  List all steps found in <path>"
  echo "  -t, --track <path>       Add a NEXTSTEP file to tracker file(name must be NEXTSTEP)"
  echo "  -u, --untrack <path>     Remove a NEXTSTEP file from tracker file"
  echo ""
  echo "Example: $ nextstep -> list next step for each NEXTSTEP file in tracker file"
  echo "Example: $ nextstep /path/to/NEXTSTEP -> open file on next step line"
  echo "Example: $ nextstep -l /path/to/NEXTSTEP -> list tasks in file"
  echo ""
  exit 0
}

safe_commit() {
    local NEXTSTEP_FILE="$1"

    if [ -z "$NEXTSTEP_FILE" ]; then
        error "usage: safe_commit <task_file>"
    fi

    # Ensure inside a git repo
    [ git rev-parse --is-inside-work-tree >/dev/null 2>&1 ] || exit 0

    # Ensure no staged changes on other files
    local STAGED_OTHERS
    STAGED_OTHERS=$(git diff --cached --name-only | grep -v "^$NEXTSTEP_FILE$" || true)
    if [ -n "$STAGED_OTHERS" ]; then
        error "Other files are staged. Commit or stash them first:"
        echo "$STAGED_OTHERS"
    fi

    # Ensure no staged changes on the task file itself
    if git diff --cached --name-only | grep -q "^$NEXTSTEP_FILE$"; then
        error "Task file $NEXTSTEP_FILE has staged changes. Please unstage or commit them manually."
    fi

    git fetch origin
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    if ! git diff --quiet "$NEXTSTEP_FILE" "origin/$current_branch"; then
        error "Remote task file $NEXTSTEP_FILE has changes. Please pull and resolve before committing."
    fi

    if git diff --quiet "$NEXTSTEP_FILE"; then
        return 0
    fi

    if git ls-files -u | grep -q "^$NEXTSTEP_FILE"; then
        error "$NEXTSTEP_FILE has merge conflicts. Resolve before committing."
    fi

    git add "$NEXTSTEP_FILE" || error "Unable to git add $NEXTSTEP_FILE"
    git commit -m "Update NEXTSTEP file $NEXTSTEP_FILE" || error "Unable to git commit $NEXTSTEP_FILE"
    git push || error "Unable to git push $NEXTSTEP_FILE"
    echo "NEXTSTEP file $NEXTSTEP_FILE committed and pushed successfully."
}

config_file="$HOME/.config/nextstep/config"
tracker_file="$HOME/.config/nextstep/tracker"

list_type="next_step"

# ---- Parse command-line arguments ----
while [[ $# -gt 0 ]]; do
  case "$1" in
    -e|--edit)
      if [ ! -f "$tracker_file" ]; then
        mkdir -p "$(dirname "$tracker_file")"
        touch "$tracker_file"
      fi
      vim "$tracker_file"
      exit 0
      ;;

    -h|--help)
      show_help
      ;;

    # ---------------- TRACK ----------------
    -t|--track)
      shift
      track_path="$1"
      if [ -z "$track_path" ]; then
        error "Missing argument for -t|--track"
      fi

      # Convert relative → absolute
      if [[ "$track_path" != /* ]]; then
        track_path="$PWD/$track_path"
      fi

      # ---- enforce filename is exactly NEXTSTEP ----
      if [[ "$(basename "$track_path")" != "NEXTSTEP" ]]; then
        error "Refusing to track: filename must be exactly 'NEXTSTEP'"
      fi

      # Ensure file exists
      if [ ! -f "$track_path" ]; then
        touch "$track_path" || error "Unable to create: $track_path"
      fi

      mkdir -p "$(dirname "$tracker_file")"
      touch "$tracker_file"

      if grep -Fxq "$track_path" "$tracker_file"; then
        warning "Path already tracked: $track_path"
        exit 0
      fi

      echo "$track_path" >> "$tracker_file"
      exit 0
      ;;

    # ---------------- UNTRACK ----------------
    -u|--untrack)
      shift
      untrack_path="$1"
      if [ -z "$untrack_path" ]; then
        error "Missing argument for -u|--untrack"
      fi

      # Convert relative → absolute
      if [[ "$untrack_path" != /* ]]; then
        untrack_path="$PWD/$untrack_path"
      fi

      # ---- enforce filename is exactly NEXTSTEP ----
      if [[ "$(basename "$untrack_path")" != "NEXTSTEP" ]]; then
        error "Cannot untrack: filename must be exactly 'NEXTSTEP'"
      fi

      if [ ! -f "$tracker_file" ]; then
        warning "Projects file not found at $tracker_file"
        exit 0
      fi

      if ! grep -Fxq "$untrack_path" "$tracker_file"; then
        warning "Path not tracked: $untrack_path"
        exit 0
      fi

      grep -Fxv "$untrack_path" "$tracker_file" > "$tracker_file.tmp" &&
      mv "$tracker_file.tmp" "$tracker_file"
      exit 0
      ;;
    -l|--list-steps)
      list_steps=1
      ;;
    *)
      file_path="$1"
      list_type="file"
      ;;
  esac
  shift
done

# ---- Existing nextstep NEXTSTEP-scanning logic ----

if [ ! -f "$tracker_file" ]; then
  error "Projects file not found at $tracker_file"
fi

git_commit="$(grep '^git_commit=' "$config_file")"
git_commit="${git_commit#git_commit=}"

if [ "$list_type" = "next_step" ]; then
  selection="$(
  while IFS= read -r file_path; do
    [[ -z "$file_path" || "$file_path" =~ ^[[:space:]]*$ || "$file_path" =~ ^# ]] && continue


    # ---- enforce filename is exactly NEXTSTEP ----
    if [[ "$(basename "$file_path")" != "NEXTSTEP" ]]; then
      warning "Skipping non-NEXTSTEP file in projects file: $file_path"
      continue
    fi

    if [ -f "$file_path" ]; then
      line_number=0
      [[ "$file_path" =~ ^"$HOME"(/|$) ]] && file_path_display="~${file_path#$HOME}" || file_path_display="$file_path"

      file_path_display="${file_path_display%/NEXTSTEP}"

      first_task="$(while IFS= read -r line; do
        let line_number=line_number+1
        if [[ "$line" == NEXTSTEP\ * ]]; then
          task="${line#NEXTSTEP }"
          echo -e "\033[36m$file_path_display:$line_number:\033[37m$task"
          break
        fi
      done < "$file_path")"
    else
      error "File not found: $file_path"
    fi

    if [ "$first_task" = "" ]; then
      echo -e "\033[36m$file_path_display:1:\033[31m⚠️NO NEXT NEXTSTEP"
    else
      echo -e "$first_task"
    fi

  done < "$tracker_file" | fzy --lines=$(($(tput lines)-2)) )"

  [ "$selection" = "" ] && exit 0

  selection="$(echo $selection | sed 's/\x1b\[[0-9;]*m//g')"
  IFS=':' read -r file_path line_number task <<< "$selection"
  [[ "$file_path" =~ ^~ ]] && file_path="$HOME${file_path#?}"
  file_path="$file_path/NEXTSTEP"

  if [ "$line_number" != "" ]; then
    vim +$line_number "$file_path"
  else
    vim "$file_path"
  fi
fi


if [[ "$list_type" = "file" && $list_steps -eq 1 ]]; then
  # ---- enforce filename is exactly NEXTSTEP ----
  if [[ "$(basename "$file_path")" != "NEXTSTEP" ]]; then
    "File must be called NEXTSTEP"
  fi

  selection="$(
  line_number=0
  while IFS= read -r line; do
    [[ "$file_path" =~ ^"$HOME"(/|$) ]] && file_path_display="~${file_path#$HOME}" || file_path_display="$file_path"

    file_path_display="${file_path_display%/NEXTSTEP}"

    let line_number=line_number+1
    if [[ "$line" == NEXTSTEP\ * ]]; then
      echo -e "\033[36m$line_number:\033[37m$line"
    fi

    if [ $line_number -eq 0 ]; then
      echo -e "\033[36m1:\033[31m⚠️NO NEXT STEP"
    fi

  done < "$file_path" | fzy --lines=$(($(tput lines)-2)) )"

  [ "$selection" = "" ] && exit 0

  selection="$(echo $selection | sed 's/\x1b\[[0-9;]*m//g')"
  IFS=':' read -r line_number task <<< "$selection"

  if [ "$line_number" != "" ]; then
    vim +$line_number "$file_path"
  else
    vim "$file_path"
  fi
elif [ "$list_type" = "file" ]; then

  # ---- enforce filename is exactly NEXTSTEP ----
  if [[ "$(basename "$file_path")" != "NEXTSTEP" ]]; then
    error "Only files named exactly 'NEXTSTEP' are valid"
  fi

  if [ -f "$file_path" ]; then
    line_number=0
    while IFS= read -r line; do
      let line_number=line_number+1
      [[ "$line" == NEXTSTEP\ * ]] && break
    done < "$file_path"
  else
    error "File not found: $file_path"
  fi

  vim +$line_number "$file_path"
fi

[ "$git_commit" = "yes" ] && safe_commit "$file_path"

