#!/bin/bash

# Function to print a warning message (Yellow)
warning() {
  echo -e "\033[33mWarning: $1\033[0m"
}

# Function to print an error message and exit with status 1 (Red)
error() {
  echo -e "\033[31mError: $1\033[0m"
  exit 1
}

# Help message
show_help() {
  echo "Usage: $0 [-h|--help] [-t|--track <path>] [-u|--untrack <path>] [<path>]"
  echo ""
  echo "Options:"
  echo "  -h, --help               Show this help message"
  echo "  -l, --list               List tracked nextstep files"
  echo "  -t, --track <path>       Add a file path to the tracker config, create file if not exists"
  echo "  -u, --untrack <path>     Remove a file path from the tracker config"
  echo ""
  echo "Example: $ nextstep -> list next step for each tracked file"
  echo "Example: $ nextstep my_project.nextstep -> list all steps for file"
  echo ""
  exit 0
}

config_file="$HOME/.config/nextstep"
file_list=$(sort "$config_file")
list_type="next_step"

# ---- Parse command-line arguments ----
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      show_help
      ;;
    -l|--list)
      list_type="files"
      ;;
    # ---------------- TRACK ----------------
    -t|--track)
      shift
      track_path="$1"
      if [ -z "$track_path" ]; then
        error "Missing argument for -t|--track"
      fi

      # Convert relative → absolute
      if [[ "$track_path" != /* ]]; then
        track_path="$PWD/$track_path"
      fi

      # Ensure file exists
      if [ ! -f "$track_path" ]; then
        touch "$track_path" || error "Unable to create: $track_path"
      fi

      # Ensure config directory + file exist
      mkdir -p "$(dirname "$config_file")"
      touch "$config_file"

      # Check for duplicates
      if grep -Fxq "$track_path" "$config_file"; then
        warning "Path already tracked: $track_path"
        exit 0
      fi

      echo "$track_path" >> "$config_file"
      #echo "Added: $track_path"
      exit 0
      ;;

    # ---------------- UNTRACK ----------------
    -u|--untrack)
      shift
      untrack_path="$1"
      if [ -z "$untrack_path" ]; then
        error "Missing argument for -u|--untrack"
      fi

      # Convert relative → absolute
      if [[ "$untrack_path" != /* ]]; then
        untrack_path="$PWD/$untrack_path"
      fi

      # Check if the config file exists
      if [ ! -f "$config_file" ]; then
        warning "Configuration file not found at $config_file"
        exit 0
      fi

      # Check if the path is in the config file
      if ! grep -Fxq "$untrack_path" "$config_file"; then
        warning "Path not tracked: $untrack_path"
        exit 0
      fi

      # Remove the entry
      grep -Fxv "$untrack_path" "$config_file" > "$config_file.tmp" &&
      mv "$config_file.tmp" "$config_file"

      #echo "Removed: $untrack_path"
      exit 0
      ;;

    *)
      file_list="$1"
      list_type="file"
      ;;
  esac
  shift
done

# ---- Existing nextstep TODO-scanning logic ----

if [ ! -f "$config_file" ]; then
  error "Configuration file not found at $config_file"
fi

# Get next step id string
next_step_prefix="$(grep '^next_step=' "$config_file")"
next_step_prefix="${next_step_prefix#next_step=}"
[ "$next_step_prefix" = "" ] && next_step_prefix=TODO

selection="$(

while IFS= read -r file_path; do
  # skip workflow setting
  if [[ "$file_path" == next_step=* ]]; then continue; fi

  if [ -f "$file_path" ]; then

    if [ "$list_type" = "next_step" ] || [ "$list_type" = "file" ]; then
      line_number=0
      while IFS= read -r line; do
        let line_number=line_number+1
        if [[ "$line" == TODO\ * ]]; then
          task="${line#TODO }"
          [[ "$file_path" =~ ^"$HOME"(/|$) ]] && file_path_display="~${file_path#$HOME}" || file_path_display="$file_path"

          # Print the file path (blue), task (bold white), and line number (cyan)
          echo -e "\033[36m$file_path_display:$line_number:\033[37m$task"

          [ "$list_type" = "next_step" ] && break
        fi
      done < "$file_path"
    else
      echo -e "\033[36m$file_path\033[37m"
    fi
  else
    warning "File not found: $file_path"
  fi
done <<< "$file_list" | fzy --lines=$(($(tput lines)-2)) )"


[ "$selection" = "" ] && exit 0

#strips out any escape codes/colors
selection="$(echo $selection | sed 's/\x1b\[[0-9;]*m//g')"

IFS=':' read -r file_path line_number task <<< "$selection"

[[ "$file_path" =~ ^~ ]] && file_path="$HOME${file_path#?}"

if [ "$line_number" != "" ]; then
  vim +$line_number "$file_path"
else
  vim "$file_path"
fi

